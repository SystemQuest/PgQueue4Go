// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: jobs.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearQueue = `-- name: ClearQueue :exec
DELETE FROM pgqueue_jobs WHERE entrypoint = ANY($1::text[])
`

func (q *Queries) ClearQueue(ctx context.Context, dollar_1 []string) error {
	_, err := q.db.Exec(ctx, clearQueue, dollar_1)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM pgqueue_jobs WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const deleteJobs = `-- name: DeleteJobs :exec
DELETE FROM pgqueue_jobs WHERE id = ANY($1::int[])
`

func (q *Queries) DeleteJobs(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.Exec(ctx, deleteJobs, dollar_1)
	return err
}

const dequeueJobsAtomic = `-- name: DequeueJobsAtomic :many
WITH selected_jobs AS (
    SELECT id, priority, created, updated, status, entrypoint, payload
    FROM pgqueue_jobs
    WHERE entrypoint = ANY($1::text[])
      AND status = 'queued'
    ORDER BY priority DESC, id ASC
    FOR UPDATE SKIP LOCKED
    LIMIT $2
),
updated_jobs AS (
    UPDATE pgqueue_jobs
    SET status = 'picked', updated = NOW()
    WHERE id IN (SELECT id FROM selected_jobs)
    RETURNING id, priority, created, updated, status, entrypoint, payload
)
SELECT id, priority, created, updated, status, entrypoint, payload FROM updated_jobs
ORDER BY priority DESC, id ASC
`

type DequeueJobsAtomicParams struct {
	Column1 []string `db:"column_1" json:"column_1"`
	Limit   int32    `db:"limit" json:"limit"`
}

type DequeueJobsAtomicRow struct {
	ID         int32              `db:"id" json:"id"`
	Priority   int32              `db:"priority" json:"priority"`
	Created    pgtype.Timestamptz `db:"created" json:"created"`
	Updated    pgtype.Timestamptz `db:"updated" json:"updated"`
	Status     QueueStatus        `db:"status" json:"status"`
	Entrypoint string             `db:"entrypoint" json:"entrypoint"`
	Payload    []byte             `db:"payload" json:"payload"`
}

func (q *Queries) DequeueJobsAtomic(ctx context.Context, arg DequeueJobsAtomicParams) ([]DequeueJobsAtomicRow, error) {
	rows, err := q.db.Query(ctx, dequeueJobsAtomic, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DequeueJobsAtomicRow
	for rows.Next() {
		var i DequeueJobsAtomicRow
		if err := rows.Scan(
			&i.ID,
			&i.Priority,
			&i.Created,
			&i.Updated,
			&i.Status,
			&i.Entrypoint,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dequeueJobsByEntrypoint = `-- name: DequeueJobsByEntrypoint :many
SELECT id, priority, created, updated, status, entrypoint, payload
FROM pgqueue_jobs
WHERE entrypoint = ANY($1::text[])
  AND status = 'queued'
ORDER BY priority DESC, id ASC
FOR UPDATE SKIP LOCKED
LIMIT $2
`

type DequeueJobsByEntrypointParams struct {
	Column1 []string `db:"column_1" json:"column_1"`
	Limit   int32    `db:"limit" json:"limit"`
}

func (q *Queries) DequeueJobsByEntrypoint(ctx context.Context, arg DequeueJobsByEntrypointParams) ([]PgqueueJobs, error) {
	rows, err := q.db.Query(ctx, dequeueJobsByEntrypoint, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PgqueueJobs
	for rows.Next() {
		var i PgqueueJobs
		if err := rows.Scan(
			&i.ID,
			&i.Priority,
			&i.Created,
			&i.Updated,
			&i.Status,
			&i.Entrypoint,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dequeueRetryJobsAtomic = `-- name: DequeueRetryJobsAtomic :many
WITH selected_jobs AS (
    SELECT id, priority, created, updated, status, entrypoint, payload
    FROM pgqueue_jobs
    WHERE entrypoint = ANY($1::text[])
      AND status = 'picked'
      AND updated < NOW() - $2::interval
    ORDER BY updated ASC, id ASC
    FOR UPDATE SKIP LOCKED
    LIMIT $3
),
updated_jobs AS (
    UPDATE pgqueue_jobs
    SET status = 'picked', updated = NOW()
    WHERE id IN (SELECT id FROM selected_jobs)
    RETURNING id, priority, created, updated, status, entrypoint, payload
)
SELECT id, priority, created, updated, status, entrypoint, payload FROM updated_jobs
ORDER BY updated ASC, id ASC
`

type DequeueRetryJobsAtomicParams struct {
	Column1 []string        `db:"column_1" json:"column_1"`
	Column2 pgtype.Interval `db:"column_2" json:"column_2"`
	Limit   int32           `db:"limit" json:"limit"`
}

type DequeueRetryJobsAtomicRow struct {
	ID         int32              `db:"id" json:"id"`
	Priority   int32              `db:"priority" json:"priority"`
	Created    pgtype.Timestamptz `db:"created" json:"created"`
	Updated    pgtype.Timestamptz `db:"updated" json:"updated"`
	Status     QueueStatus        `db:"status" json:"status"`
	Entrypoint string             `db:"entrypoint" json:"entrypoint"`
	Payload    []byte             `db:"payload" json:"payload"`
}

func (q *Queries) DequeueRetryJobsAtomic(ctx context.Context, arg DequeueRetryJobsAtomicParams) ([]DequeueRetryJobsAtomicRow, error) {
	rows, err := q.db.Query(ctx, dequeueRetryJobsAtomic, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DequeueRetryJobsAtomicRow
	for rows.Next() {
		var i DequeueRetryJobsAtomicRow
		if err := rows.Scan(
			&i.ID,
			&i.Priority,
			&i.Created,
			&i.Updated,
			&i.Status,
			&i.Entrypoint,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const enqueueJob = `-- name: EnqueueJob :exec
INSERT INTO pgqueue_jobs (priority, entrypoint, payload, status)
VALUES ($1, $2, $3, 'queued')
`

type EnqueueJobParams struct {
	Priority   int32  `db:"priority" json:"priority"`
	Entrypoint string `db:"entrypoint" json:"entrypoint"`
	Payload    []byte `db:"payload" json:"payload"`
}

func (q *Queries) EnqueueJob(ctx context.Context, arg EnqueueJobParams) error {
	_, err := q.db.Exec(ctx, enqueueJob, arg.Priority, arg.Entrypoint, arg.Payload)
	return err
}

const getJob = `-- name: GetJob :one
SELECT id, priority, created, updated, status, entrypoint, payload FROM pgqueue_jobs WHERE id = $1
`

func (q *Queries) GetJob(ctx context.Context, id int32) (PgqueueJobs, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i PgqueueJobs
	err := row.Scan(
		&i.ID,
		&i.Priority,
		&i.Created,
		&i.Updated,
		&i.Status,
		&i.Entrypoint,
		&i.Payload,
	)
	return i, err
}

const getQueueSize = `-- name: GetQueueSize :many
SELECT
    count(*) AS count,
    priority,
    entrypoint,
    status
FROM pgqueue_jobs
GROUP BY entrypoint, priority, status
ORDER BY count DESC, entrypoint, priority, status
`

type GetQueueSizeRow struct {
	Count      int64       `db:"count" json:"count"`
	Priority   int32       `db:"priority" json:"priority"`
	Entrypoint string      `db:"entrypoint" json:"entrypoint"`
	Status     QueueStatus `db:"status" json:"status"`
}

func (q *Queries) GetQueueSize(ctx context.Context) ([]GetQueueSizeRow, error) {
	rows, err := q.db.Query(ctx, getQueueSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQueueSizeRow
	for rows.Next() {
		var i GetQueueSizeRow
		if err := rows.Scan(
			&i.Count,
			&i.Priority,
			&i.Entrypoint,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRetryJobs = `-- name: GetRetryJobs :many
SELECT id, priority, created, updated, status, entrypoint, payload
FROM pgqueue_jobs
WHERE entrypoint = ANY($1::text[])
  AND status = 'picked'
  AND updated < NOW() - $2::interval
ORDER BY updated ASC, id ASC
FOR UPDATE SKIP LOCKED
LIMIT $3
`

type GetRetryJobsParams struct {
	Column1 []string        `db:"column_1" json:"column_1"`
	Column2 pgtype.Interval `db:"column_2" json:"column_2"`
	Limit   int32           `db:"limit" json:"limit"`
}

func (q *Queries) GetRetryJobs(ctx context.Context, arg GetRetryJobsParams) ([]PgqueueJobs, error) {
	rows, err := q.db.Query(ctx, getRetryJobs, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PgqueueJobs
	for rows.Next() {
		var i PgqueueJobs
		if err := rows.Scan(
			&i.ID,
			&i.Priority,
			&i.Created,
			&i.Updated,
			&i.Status,
			&i.Entrypoint,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markJobsAsPicked = `-- name: MarkJobsAsPicked :exec
UPDATE pgqueue_jobs
SET status = 'picked', updated = NOW()
WHERE id = ANY($1::int[])
`

func (q *Queries) MarkJobsAsPicked(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.Exec(ctx, markJobsAsPicked, dollar_1)
	return err
}

const truncateQueue = `-- name: TruncateQueue :exec
TRUNCATE pgqueue_jobs
`

func (q *Queries) TruncateQueue(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateQueue)
	return err
}

const updateJobStatus = `-- name: UpdateJobStatus :exec
UPDATE pgqueue_jobs 
SET status = $2, updated = NOW()
WHERE id = $1
`

type UpdateJobStatusParams struct {
	ID     int32       `db:"id" json:"id"`
	Status QueueStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) error {
	_, err := q.db.Exec(ctx, updateJobStatus, arg.ID, arg.Status)
	return err
}
