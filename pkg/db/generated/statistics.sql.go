// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: statistics.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearStatistics = `-- name: ClearStatistics :exec
DELETE FROM pgqueue_statistics WHERE entrypoint = ANY($1::text[])
`

func (q *Queries) ClearStatistics(ctx context.Context, dollar_1 []string) error {
	_, err := q.db.Exec(ctx, clearStatistics, dollar_1)
	return err
}

const deleteJobsForStats = `-- name: DeleteJobsForStats :many
DELETE FROM pgqueue_jobs
WHERE id = ANY($1::int[])
RETURNING 
    id,
    priority,
    entrypoint,
    DATE_TRUNC('sec', created at time zone 'UTC') AS created,
    DATE_TRUNC('sec', AGE(updated, created)) AS time_in_queue
`

type DeleteJobsForStatsRow struct {
	ID          int32           `db:"id" json:"id"`
	Priority    int32           `db:"priority" json:"priority"`
	Entrypoint  string          `db:"entrypoint" json:"entrypoint"`
	Created     pgtype.Interval `db:"created" json:"created"`
	TimeInQueue pgtype.Interval `db:"time_in_queue" json:"time_in_queue"`
}

func (q *Queries) DeleteJobsForStats(ctx context.Context, dollar_1 []int32) ([]DeleteJobsForStatsRow, error) {
	rows, err := q.db.Query(ctx, deleteJobsForStats, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeleteJobsForStatsRow
	for rows.Next() {
		var i DeleteJobsForStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Priority,
			&i.Entrypoint,
			&i.Created,
			&i.TimeInQueue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatistics = `-- name: GetStatistics :many
SELECT
    count,
    created,
    time_in_queue,
    entrypoint,
    priority,
    status
FROM pgqueue_statistics
ORDER BY id DESC
LIMIT $1
`

type GetStatisticsRow struct {
	Count       int64              `db:"count" json:"count"`
	Created     pgtype.Timestamptz `db:"created" json:"created"`
	TimeInQueue pgtype.Interval    `db:"time_in_queue" json:"time_in_queue"`
	Entrypoint  string             `db:"entrypoint" json:"entrypoint"`
	Priority    int32              `db:"priority" json:"priority"`
	Status      StatisticsStatus   `db:"status" json:"status"`
}

func (q *Queries) GetStatistics(ctx context.Context, limit int32) ([]GetStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getStatistics, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatisticsRow
	for rows.Next() {
		var i GetStatisticsRow
		if err := rows.Scan(
			&i.Count,
			&i.Created,
			&i.TimeInQueue,
			&i.Entrypoint,
			&i.Priority,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertJobStatistics = `-- name: InsertJobStatistics :exec
INSERT INTO pgqueue_statistics (
    priority,
    entrypoint,
    time_in_queue,
    created,
    status,
    count
)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (
    priority,
    DATE_TRUNC('sec', created at time zone 'UTC'),
    DATE_TRUNC('sec', time_in_queue),
    status,
    entrypoint
)
DO UPDATE SET count = pgqueue_statistics.count + EXCLUDED.count
`

type InsertJobStatisticsParams struct {
	Priority    int32              `db:"priority" json:"priority"`
	Entrypoint  string             `db:"entrypoint" json:"entrypoint"`
	TimeInQueue pgtype.Interval    `db:"time_in_queue" json:"time_in_queue"`
	Created     pgtype.Timestamptz `db:"created" json:"created"`
	Status      StatisticsStatus   `db:"status" json:"status"`
	Count       int64              `db:"count" json:"count"`
}

func (q *Queries) InsertJobStatistics(ctx context.Context, arg InsertJobStatisticsParams) error {
	_, err := q.db.Exec(ctx, insertJobStatistics,
		arg.Priority,
		arg.Entrypoint,
		arg.TimeInQueue,
		arg.Created,
		arg.Status,
		arg.Count,
	)
	return err
}

const truncateStatistics = `-- name: TruncateStatistics :exec
TRUNCATE pgqueue_statistics
`

func (q *Queries) TruncateStatistics(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateStatistics)
	return err
}
